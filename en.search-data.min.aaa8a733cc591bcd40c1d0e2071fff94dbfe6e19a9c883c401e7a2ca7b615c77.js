'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/dev/c/callgraph_usage/',title:"Callgraph--函数调用树生成器",section:"C",content:"介绍 #  Callgraph 是一个生成C代码函数调用树的工具，与以下三个工具配合使用：\n cflow/calltree: 用于生成 C 函数调用树 graphviz: 处理 dot 文本图形语言 tree2dotx: 用于把 C 函数调用树转换为 dot 格式的脚本  安装 #  Environment: Ubuntu 20.04\nsudo apt-get install cflow graphviz 接下来安装 tree2dotx 和 Callgraph，这里都默认安装到 /usr/local/bin。\nsudo wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/tree2dotx -o /usr/local/bin/tree2dotx sudo wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/callgraph -o /usr/local/bin/callgraph sudo chmod +x /usr/local/bin/{tree2dotx,callgraph} 使用 #  callgraph -f main -d ./file.c -F \u0026#34;printf print\u0026#34; -D 2 -b firefox  -f: 指定目标函数\n-d: 指定函数所在文件（或者指定函数搜索路径）\n-F: 指定不感兴趣的分支\n-D: 指定生成调用树的深度\n-b: 指定打开方式\n "}),a.add({id:1,href:'/docs/dev/go/init/',title:"Init--初始化函数",section:"Go",content:"作用 #   初始化不能采用初始化表达式初始化的变量。 程序运行前的注册。 实现sync.Once功能。  规则 #   先于main函数自动执行。 不能被其他函数调用。 没有输入参数、返回值。 每个包可以有多个init函数。 包的每个源文件也可以有多个init函数。 同一个包的init执行顺序，golang没有明确定义。 不同包的init函数按照包导入的依赖关系决定执行顺序。  "}),a.add({id:2,href:'/docs/dev/c/inline/',title:"关键字Inline的使用说明",section:"C",content:"作用 #  避免一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。\n规则 #   关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用 inline只适合函数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数  以下情况不宜使用内联：\n 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。  总结 #   内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收 获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline 不应该出现在函数的声明中）。 因此,将内联函数放在头文件里实现是合适的,省却你为每个文件实现一次的麻烦.而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为,即是说,如果不是每个文件里的定义都一样,那么,编译器展开的是哪一个,那要看具体的编译器而定.所以,最好将内联函数定义放在头文件中.   例子 #  #include \u0026lt;stdio.h\u0026gt; //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 \u0026gt; 0) ? \u0026quot;奇\u0026quot; : \u0026quot;偶\u0026quot;; } int main() { int i = 0; for (i=1; i \u0026lt; 100; i++) { printf(\u0026quot;i:%d 奇偶性:%s /n\u0026quot;, i, dbtest(i)); } } 上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2\u0026gt;0)?\u0026ldquo;奇\u0026rdquo;:\u0026ldquo;偶\u0026quot;这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。\n"})})()