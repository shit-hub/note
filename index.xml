<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sanjo's Note</title><link>http://note.shit-hub.com/</link><description>Recent content on Sanjo's Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://note.shit-hub.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Callgraph--函数调用树生成器</title><link>http://note.shit-hub.com/docs/dev/c/callgraph_usage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://note.shit-hub.com/docs/dev/c/callgraph_usage/</guid><description>介绍 # Callgraph 是一个生成C代码函数调用树的工具，与以下三个工具配合使用：
cflow/calltree: 用于生成 C 函数调用树 graphviz: 处理 dot 文本图形语言 tree2dotx: 用于把 C 函数调用树转换为 dot 格式的脚本 安装 # Environment: Ubuntu 20.04
sudo apt-get install cflow graphviz 接下来安装 tree2dotx 和 Callgraph，这里都默认安装到 /usr/local/bin。
sudo wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/tree2dotx -o /usr/local/bin/tree2dotx sudo wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/callgraph -o /usr/local/bin/callgraph sudo chmod +x /usr/local/bin/{tree2dotx,callgraph} 使用 # callgraph -f main -d ./file.c -F &amp;#34;printf print&amp;#34; -D 2 -b firefox -f: 指定目标函数</description></item><item><title>Go doc--文档管理器</title><link>http://note.shit-hub.com/docs/dev/go/godoc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://note.shit-hub.com/docs/dev/go/godoc/</guid><description>作用 # 打印与由Package相关参数（package，const，func，type，var，method或struct字段）标识的项目相关的文档注释，然后单行总结“ 项目（包的包级别声明，类型的方法等）。
使用方法 # go doc [-u] [-c] [package|[package.]symbol[.methodOrField]] Option Description -all 显示所有文档 -c 匹配程序实体时，大小写敏感 -cmd 将命令（main包）视为常规程序包 -src 显示完整源代码 -u 显示未导出的程序实体 编写文档规则 # 注释: // xxx 段落：行首字母大写 换行：添加一个注释空行 预格式化（示例代码）：行首缩进 在package, const, type, func等关键字上面并且紧邻关键字的注释才会被展示 // 此行注释被省略 // 此行注释被展示 // // 此行注释被展示2 package banana type, const, func以名称为注释的开头, package以Package name为注释的开头 // Package banana .</description></item><item><title>Go mod--依赖管理器</title><link>http://note.shit-hub.com/docs/dev/go/gomod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://note.shit-hub.com/docs/dev/go/gomod/</guid><description>Environment: Ubuntu + Go 1.13
Open Go module # Add forrowing environment variable:
1.11 or 1.12 export GO111MODULE=on export GOPROXY=https://goproxy.io 1.13 and later go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct Run that command after delete the origin environment variable.
Usage: go get # 使用go module之后，go get 拉取依赖的方式就发生了变化 下载项目依赖
go get ./... 拉取最新的版本(优先择取 tag)
go get golang.org/x/text@latest 拉取 master 分支的最新 commit
go get golang.</description></item><item><title>关键字Inline的使用说明</title><link>http://note.shit-hub.com/docs/dev/c/inline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://note.shit-hub.com/docs/dev/c/inline/</guid><description>作用 # 避免一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。
规则 # 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用 inline只适合函数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数 以下情况不宜使用内联：
如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 总结 # 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收 获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline 不应该出现在函数的声明中）。 因此,将内联函数放在头文件里实现是合适的,省却你为每个文件实现一次的麻烦.而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为,即是说,如果不是每个文件里的定义都一样,那么,编译器展开的是哪一个,那要看具体的编译器而定.所以,最好将内联函数定义放在头文件中.  例子 # #include &amp;lt;stdio.h&amp;gt; //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 &amp;gt; 0) ? &amp;quot;奇&amp;quot; : &amp;quot;偶&amp;quot;; } int main() { int i = 0; for (i=1; i &amp;lt; 100; i++) { printf(&amp;quot;i:%d 奇偶性:%s /n&amp;quot;, i, dbtest(i)); } } 上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2&amp;gt;0)?</description></item><item><title>Init--初始化函数</title><link>http://note.shit-hub.com/docs/dev/go/init/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://note.shit-hub.com/docs/dev/go/init/</guid><description>作用 # 初始化不能采用初始化表达式初始化的变量。 程序运行前的注册。 实现sync.Once功能。 规则 # 先于main函数自动执行。 不能被其他函数调用。 没有输入参数、返回值。 每个包可以有多个init函数。 包的每个源文件也可以有多个init函数。 同一个包的init执行顺序，golang没有明确定义。 不同包的init函数按照包导入的依赖关系决定执行顺序。 备注 # 设置GODEBUG环境变量: inittrace=1，可以在运行时会为每个包的 init 打印一行标准错误信息，总结其执行时间和内存分配。 若只想调用该包的init函数，不使用包导出的变量或者方法，可使用类似以下方法导入： import _ &amp;#34;net/http/pprof&amp;#34;</description></item><item><title>Grpc使用</title><link>http://note.shit-hub.com/docs/dev/go/grpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://note.shit-hub.com/docs/dev/go/grpc/</guid><description>Install # Install protoc wget https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip unzip protoc-3.13.0-linux-x86_64.zip -d /usr/local/protoc export PATH=$PATH:/usr/local/protoc/bin source ~/.bashrc Download protoc-gen-go go get -u github.com/golang/protobuf/protoc-gen-go go install $GOPATH/src/github.com/golang/protobuf/protoc-gen-go Usage # Create *.proto file // Specify syntax format, note that proto3 no supports required and optimal in proto2 anymore syntax = &amp;quot;proto3&amp;quot;; // Specifies the package name of the generated *.pb.go package grpc; // Specifies the package path of the generated *.</description></item><item><title>安装Grpcurl</title><link>http://note.shit-hub.com/docs/dev/go/grpcurl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://note.shit-hub.com/docs/dev/go/grpcurl/</guid><description>Environment:
System: linux Go: 1.13+ Install # Install dependent package mkdir -p $GOPATH/src/google.golang.org git clone https://github.com/protocolbuffers/protobuf-go.git $GOPATH/src/google.golang.org/protobuf git clone https://github.com/googleapis/go-genproto.git $GOPATH/src/google.golang.org/genproto git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc git clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/net git clone https://github.com/golang/sys.git $GOPATH/src/golang.org/x/sys git clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/text Download grpcurl go get github.com/fullstorydev/grpcurl Install go install $GOPATH/src/github.com/fullstorydev/grpcurl/cmd/grpcurl if tips no dependent package, go to $GOPATH/src/github.com/fullstorydev/grpcurl/ to run go build ./cmd/grpcurl</description></item></channel></rss>