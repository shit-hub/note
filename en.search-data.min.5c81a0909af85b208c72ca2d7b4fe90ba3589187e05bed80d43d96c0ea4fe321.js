'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/dev/c/callgraph_usage/',title:"Callgraph--函数调用树生成器",section:"C",content:"介绍 #  Callgraph 是一个生成C代码函数调用树的工具，与以下三个工具配合使用：\n cflow/calltree: 用于生成 C 函数调用树 graphviz: 处理 dot 文本图形语言 tree2dotx: 用于把 C 函数调用树转换为 dot 格式的脚本  安装 #  Environment: Ubuntu 20.04\nsudo apt-get install cflow graphviz 接下来安装 tree2dotx 和 Callgraph，这里都默认安装到 /usr/local/bin。\nsudo wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/tree2dotx -o /usr/local/bin/tree2dotx sudo wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/callgraph -o /usr/local/bin/callgraph sudo chmod +x /usr/local/bin/{tree2dotx,callgraph} 使用 #  callgraph -f main -d ./file.c -F \u0026#34;printf print\u0026#34; -D 2 -b firefox  -f: 指定目标函数\n-d: 指定函数所在文件（或者指定函数搜索路径）\n-F: 指定不感兴趣的分支\n-D: 指定生成调用树的深度\n-b: 指定打开方式\n "}),a.add({id:1,href:'/docs/dev/go/godoc/',title:"Go doc--文档管理器",section:"Go",content:"作用 #  打印与由Package相关参数（package，const，func，type，var，method或struct字段）标识的项目相关的文档注释，然后单行总结“ 项目（包的包级别声明，类型的方法等）。\n使用方法 #  go doc [-u] [-c] [package|[package.]symbol[.methodOrField]]    Option Description     -all 显示所有文档   -c 匹配程序实体时，大小写敏感   -cmd 将命令（main包）视为常规程序包   -src 显示完整源代码   -u 显示未导出的程序实体    编写文档规则 #   注释: // xxx 段落：行首字母大写 换行：添加一个注释空行 预格式化（示例代码）：行首缩进 在package, const, type, func等关键字上面并且紧邻关键字的注释才会被展示 // 此行注释被省略  // 此行注释被展示 // // 此行注释被展示2 package banana  type, const, func以名称为注释的开头, package以Package name为注释的开头 // Package banana ... package banana // Xyz ... const Xyz = 1 // Abc ... type Abc struct {} // Bcd ... func Bcd() {}  package注释应不超过三行， 如果超过三行，应放到doc.go中 如果有多个package注释，按照文件名排序显示， 最多显示523字节  Godoc #  用途及用法于go doc类似，但可用于http服务器，方便文档查看。\n安装 #  go install golang.org/x/tools/cmd/godoc@latest 使用方法 #  godoc -http :8080 --index -play 然后浏览器访问http://127.0.0.1:8080即可\n参考文档 #   Go doc官方说明 Godoc官方博文 Godoc技巧  "}),a.add({id:2,href:'/docs/dev/go/gomod/',title:"Go mod--依赖管理器",section:"Go",content:"Environment: Ubuntu + Go 1.13\nOpen Go module #  Add forrowing environment variable:\n 1.11 or 1.12  export GO111MODULE=on export GOPROXY=https://goproxy.io  1.13 and later  go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct  Run that command after delete the origin environment variable.\n Usage: go get #  使用go module之后，go get 拉取依赖的方式就发生了变化 下载项目依赖\ngo get ./... 拉取最新的版本(优先择取 tag)\ngo get golang.org/x/text@latest 拉取 master 分支的最新 commit\ngo get golang.org/x/text@master 拉取 tag 为 v0.3.2 的 commit\ngo get golang.org/x/text@v0.3.2 拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2：\ngo get golang.org/x/text@342b2e 指定版本拉取，拉取v3版本\ngo get github.com/smartwalle/alipay/v3 更新\ngo get -u Usage: go mod #  初始化一个moudle，模块名为你项目名\ngo mod init \u0026lt;module name\u0026gt; 下载modules到本地cache 目前所有模块版本数据均缓存在$GOPATH/pkg/mod和$GOPATH/pkg/sum下\ngo mod download 编辑go.mod文件 选项有-json、-require和-exclude，可以使用帮助go help mod edit\ngo mod edit 以文本模式打印模块需求图\ngo mod graph 删除错误或者不使用的modules\ngo mod tidy 生成vendor目录\ngo mod vendor 验证依赖是否正确\ngo mod verify 查找依赖\ngo mod why Advance usage #  更新到最新版本\ngo get github.com/gogf/gf@version  如果没有指明 version 的情况下，则默认先下载打了 tag 的 release 版本，比如 v0.4.5 或者 v1.2.3；如果没有 release 版本，则下载最新的 pre release 版本，比如 v0.0.1-pre1。如果还没有则下载最新的 commit\n 更新到某个分支最新的代码\ngo get github.com/gogf/gf@master 更新到最新的修订版（只改bug的版本）\ngo get -u=patch github.com/gogf/gf 替代只能翻墙下载的库\ngo mod edit -replace=golang.org/x/crypto@v0.0.0=github.com/golang/crypto@latest go mod edit -replace=golang.org/x/sys@v0.0.0=github.com/golang/sys@latest 清理moudle 缓存\ngo clean -modcache 查看可下载版本\ngo list -m -versions github.com/gogf/gf "}),a.add({id:3,href:'/docs/dev/c/inline/',title:"关键字Inline的使用说明",section:"C",content:"作用 #  避免一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。\n规则 #   关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用 inline只适合函数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数  以下情况不宜使用内联：\n 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。  总结 #   内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收 获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline 不应该出现在函数的声明中）。 因此,将内联函数放在头文件里实现是合适的,省却你为每个文件实现一次的麻烦.而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为,即是说,如果不是每个文件里的定义都一样,那么,编译器展开的是哪一个,那要看具体的编译器而定.所以,最好将内联函数定义放在头文件中.   例子 #  #include \u0026lt;stdio.h\u0026gt; //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 \u0026gt; 0) ? \u0026quot;奇\u0026quot; : \u0026quot;偶\u0026quot;; } int main() { int i = 0; for (i=1; i \u0026lt; 100; i++) { printf(\u0026quot;i:%d 奇偶性:%s /n\u0026quot;, i, dbtest(i)); } } 上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2\u0026gt;0)?\u0026ldquo;奇\u0026rdquo;:\u0026ldquo;偶\u0026quot;这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。\n"}),a.add({id:4,href:'/docs/dev/go/init/',title:"Init--初始化函数",section:"Go",content:"作用 #   初始化不能采用初始化表达式初始化的变量。 程序运行前的注册。 实现sync.Once功能。  规则 #   先于main函数自动执行。 不能被其他函数调用。 没有输入参数、返回值。 每个包可以有多个init函数。 包的每个源文件也可以有多个init函数。 同一个包的init执行顺序，golang没有明确定义。 不同包的init函数按照包导入的依赖关系决定执行顺序。  备注 #   设置GODEBUG环境变量: inittrace=1，可以在运行时会为每个包的 init 打印一行标准错误信息，总结其执行时间和内存分配。 若只想调用该包的init函数，不使用包导出的变量或者方法，可使用类似以下方法导入： import _ \u0026#34;net/http/pprof\u0026#34;   "}),a.add({id:5,href:'/docs/dev/go/grpc/',title:"Grpc使用",section:"Go",content:"Install #   Install protoc  wget https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip unzip protoc-3.13.0-linux-x86_64.zip -d /usr/local/protoc export PATH=$PATH:/usr/local/protoc/bin source ~/.bashrc Download protoc-gen-go  go get -u github.com/golang/protobuf/protoc-gen-go go install $GOPATH/src/github.com/golang/protobuf/protoc-gen-go Usage #   Create *.proto file  // Specify syntax format, note that proto3 no supports required and optimal in proto2 anymore syntax = \u0026quot;proto3\u0026quot;; // Specifies the package name of the generated *.pb.go package grpc; // Specifies the package path of the generated *.pb.go package option go_package = \u0026quot;.;grpc\u0026quot;; // Service defines the service called by the development service DemoService { rpc DemoReq(DemoRequest) returns (DemoResponse) {} } message DemoRequest{ uint32 Id = 1; string Name = 2; } message DemoResponse{ } Generate  protoc -I . --go_out=plugins=grpc:. ./*.proto "}),a.add({id:6,href:'/docs/dev/go/grpcurl/',title:"安装Grpcurl",section:"Go",content:"Environment:\n System: linux Go: 1.13+  Install #   Install dependent package  mkdir -p $GOPATH/src/google.golang.org git clone https://github.com/protocolbuffers/protobuf-go.git $GOPATH/src/google.golang.org/protobuf git clone https://github.com/googleapis/go-genproto.git $GOPATH/src/google.golang.org/genproto git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc git clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/net git clone https://github.com/golang/sys.git $GOPATH/src/golang.org/x/sys git clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/text Download grpcurl  go get github.com/fullstorydev/grpcurl Install  go install $GOPATH/src/github.com/fullstorydev/grpcurl/cmd/grpcurl  if tips no dependent package, go to $GOPATH/src/github.com/fullstorydev/grpcurl/ to run go build ./cmd/grpcurl\n "})})()