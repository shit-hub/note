'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/dev/c/',title:"C",section:"Dev",content:"简介 #  C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。\n特点 #   易于学习。 结构化语言。 它产生高效率的程序。 它可以处理底层的活动。 它可以在多种计算机平台上编译。  C11 #  C11（也被称为C1X）指ISO标准ISO/IEC 9899:2011，是当前最新的C语言标准。在它之前的C语言标准为C99。\n新特性 #   对齐处理（Alignment）的标准化（包括_Alignas标志符，alignof运算符，aligned_alloc函数以及\u0026lt;stdalign.h\u0026gt;头文件）。 _Noreturn 函数标记，类似于 gcc 的 attribute((noreturn))。 _Generic 关键字。 多线程（Multithreading）支持，包括：  _Thread_local存储类型标识符，\u0026lt;threads.h\u0026gt;头文件，里面包含了线程的创建和管理函数。 _Atomic类型修饰符和\u0026lt;stdatomic.h\u0026gt;头文件。   增强的Unicode的支持。基于C Unicode技术报告ISO/IEC TR 19769:2004，增强了对Unicode的支持。包括为UTF-16/UTF-32编码增加了char16_t和char32_t数据类型，提供了包含unicode字符串转换函数的头文件\u0026lt;uchar.h\u0026gt;。 删除了 gets() 函数，使用一个新的更安全的函数gets_s()替代。 增加了边界检查函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。 增加了更多浮点处理宏(宏)。 匿名结构体/联合体支持。这个在gcc早已存在，C11将其引入标准。 静态断言（Static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。 新的 fopen() 模式，(\u0026quot;…x\u0026quot;)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。 新增 quick_exit() 函数作为第三种终止程序的方式。当 exit()失败时可以做最少的清理工作。  Directory #    Callgraph--函数调用树生成器     关键字Inline的使用说明     __builtin_expect使用    "}),a.add({id:1,href:'/docs/dev/c/callgraph_usage/',title:"Callgraph--函数调用树生成器",section:"C",content:"介绍 #  Callgraph 是一个生成C代码函数调用树的工具，与以下三个工具配合使用：\n cflow/calltree: 用于生成 C 函数调用树 graphviz: 处理 dot 文本图形语言 tree2dotx: 用于把 C 函数调用树转换为 dot 格式的脚本  安装 #  Environment: Ubuntu 20.04\nsudo apt-get install cflow graphviz 接下来安装 tree2dotx 和 Callgraph，这里都默认安装到 /usr/local/bin。\nsudo wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/tree2dotx -o /usr/local/bin/tree2dotx sudo wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/callgraph -o /usr/local/bin/callgraph sudo chmod +x /usr/local/bin/{tree2dotx,callgraph} 使用 #  callgraph -f main -d ./file.c -F \u0026#34;printf print\u0026#34; -D 2 -b firefox  -f: 指定目标函数\n-d: 指定函数所在文件（或者指定函数搜索路径）\n-F: 指定不感兴趣的分支\n-D: 指定生成调用树的深度\n-b: 指定打开方式\n"}),a.add({id:2,href:'/docs/dev/',title:"Dev",section:"Docs",content:"Development #  Record something about software development.\nDirectory #    C     Go     Rust     Html     Shell     Python     Embedded     Typescript     Data Structure     Design Patterns    "}),a.add({id:3,href:'/docs/ops/git/gitlab/',title:"Gitlab",section:"Git",content:"Directory #   "}),a.add({id:4,href:'/docs/dev/go/godoc/',title:"Go doc--文档管理器",section:"Go",content:"作用 #  打印与由Package相关参数（package，const，func，type，var，method或struct字段）标识的项目相关的文档注释，然后单行总结“ 项目（包的包级别声明，类型的方法等）。\n使用方法 #  go doc [-u] [-c] [package|[package.]symbol[.methodOrField]]    Option Description     -all 显示所有文档   -c 匹配程序实体时，大小写敏感   -cmd 将命令（main包）视为常规程序包   -src 显示完整源代码   -u 显示未导出的程序实体    编写文档规则 #   注释: // xxx 段落：行首字母大写 换行：添加一个注释空行 预格式化（示例代码）：行首缩进 在package, const, type, func等关键字上面并且紧邻关键字的注释才会被展示 // 此行注释被省略  // 此行注释被展示 // // 此行注释被展示2 package banana  type, const, func以名称为注释的开头, package以Package name为注释的开头 // Package banana ... package banana // Xyz ... const Xyz = 1 // Abc ... type Abc struct {} // Bcd ... func Bcd() {}  package注释应不超过三行， 如果超过三行，应放到doc.go中 如果有多个package注释，按照文件名排序显示， 最多显示523字节  Godoc #  用途及用法于go doc类似，但可用于http服务器，方便文档查看。\n安装 #  go install golang.org/x/tools/cmd/godoc@latest 使用方法 #  godoc -http :8080 --index -play 然后浏览器访问http://127.0.0.1:8080即可\n参考文档 #   Go doc官方说明 Godoc官方博文 Godoc技巧 "}),a.add({id:5,href:'/docs/ops/virtualization/kvm/',title:"Kvm",section:"Virtualization",content:"Directory #   "}),a.add({id:6,href:'/docs/ops/os/linux/',title:"Linux",section:"OS",content:"Directory #   "}),a.add({id:7,href:'/docs/ops/os/',title:"OS",section:"Ops",content:"Directory #    Linux     Mac     Windows    "}),a.add({id:8,href:'/docs/ops/tools/samba/',title:"Samba",section:"Tools",content:"Samba #  在嵌入式系统开发应用平台中，tftp、nfs和samba服务器是最常用的文件传输工具，tftp和nfs是在嵌入式Linux开发环境中经常使用的传输工具，samba则是Linux和Windows之间的文件传输工具。samba是模仿Windows网上邻居的SMB的通讯协议，将Linux操作系统“假装成”Windows操作系统，通过网上邻居的方式来进行文件传输的。\nModule #  samba有两个主要的进程smbd和nmbd。smbd进程提供了文件和打印服务，而nmbd则提供了NetBIOS名称服务和浏览支持，帮助SMB客户定位服务器，处理所有基于UDP的协议。\n /etc/samba/smb.conf 这是samba的主要配置文件，基本上仅有这个文件，而且这个配置文件本身的说明非常详细。主要的设置包括服务器全局设置，如工作组、NetBIOS名称和密码等级，以及共享目录的相关设置，如实际目录、共享资源名称和权限等两大部分。 /etc/samba/lmhosts 早期的 NetBIOS name 需额外设定，因此需要这个 lmhosts 的 NetBIOS name 对应的 IP 檔。 事实上它有点像是 /etc/hosts 的功能.只不过这个 lmhosts 对应的主机名是 NetBIOS name  /etc/sysconfig/samba 提供启动 smbd, nmbd 时，你还想要加入的相关服务参数。 /etc/samba/smbusers 由于 Windows 与 Linux 在管理员与访客的账号名称不一致，例如： administrator (windows) 及 root(linux)， 为了对应这两者之间的账号关系，可使用这个档案来设定 /var/lib/samba/private/{passdb.tdb,secrets.tdb} 管理 Samba 的用户账号/密码时，会用到的数据库档案； /usr/share/doc/samba-\u0026lt;版本\u0026gt; 这个目录包含了 SAMBA 的所有相关的技术手册  Installation #  Update soft source #  sudo apt-get update sudo apt-get upgrade sudo apt-get dist-upgrade Install samba server #  sudo apt-get install samba samba-common Add user to samba #  sudo smbpasswd -a casa Config samba #  vim /etc/samba/smb.conf [home] path = /home/casa public = yes browseable = yes public = yes read only = no writable = yes #valid users = user create mask = 0777 directory mask = 0777 #force user = nobody #force group =nogroup available = yes security = share Restart samba #  service smbd restart "}),a.add({id:9,href:'/docs/others/dome/',title:"职场相关",section:"Others",content:"职业规划 #   加强自我认知，最终实现认知升级。看清自己的天赋，发现自己的优势与卡点。 做好的人生的长期规划。很多时候我们的长期规划会影响到我们短期的选择。 学会与他人合作，建立一个非常健康、和谐的关系圈。 做一个复合型人才，保持开放的心态，不断去拓展自己的知识面和视野。 重视个人品牌的打造，个人的专业形象会影响到你的职业发展。 做一个持续成长的人，培养成长性思维，然后不断地去精进。  职业生涯 #   很多时候你能够做到什么样的位置，取决于你日常关心一些什么事情。 身边的人的重要性。建议在自己的生活圈子中找到一个你能去模仿的人，不是说让你模仿一辈子，至少在某一段生命历程中间，你能够向他去学习。 找准你的竞争力（人无我有），并在意识到自己的核心竞争力之后，并学会把目标拆解。 如果时空折叠，回到刚工作大概 3~5 年时（今年是第 18 年），给处在此时职场中人的建议。  职业选择 #   核心资源。我是谁，拥有什么，有什么特长，脱离公司的价值评价体系到外面还成立吗？ 客户细分。我的客户/用户是谁？又能给客户的客户提供什么？能给这个行业提供什么？ 价值主张。我能解决什么问题？我能提供什么价值？ 客户关系。我和客户建立了什么关系？ 渠道通路。客户怎么知道我？我怎么找到客户？ 关键活动。（在工作中）我需要做些什么？我平时通过什么来发挥价值？ 重要伙伴。在发挥价值的过程中，谁是不可或缺的伙伴？谁是你可以动员的资源？谁是我困境中的贵人？ 成本结构。我需要付出什么？（不）可量化的成本有哪些？情绪也是成本。 收入来源。我可以获得什么？（不）可量化的收获有哪些？收获减去成本，剩下的部分自己是否满意？  职业积累 #   不迷茫，定位与思维。包括在团队、在职场的规划。 做事快，效率与协作。运用时间管理、项目管理等方法，让效率更高。 被认可，表达与沟通。包括向上、向下、平级沟通。 见识广，圈子与视野。拓展圈子，多接收信息。 "}),a.add({id:10,href:'/docs/ops/virtualization/docker/',title:"Docker",section:"Virtualization",content:"Directory #   "}),a.add({id:11,href:'/docs/ops/git/',title:"Git",section:"Ops",content:"Directory #    Gitlab    "}),a.add({id:12,href:'/docs/dev/go/',title:"Go",section:"Dev",content:"Directory #    Go doc--文档管理器     Go mod--依赖管理器     Init--初始化函数     Grpc使用     安装Grpcurl     使用Gvm更换go版本    "}),a.add({id:13,href:'/docs/dev/go/gomod/',title:"Go mod--依赖管理器",section:"Go",content:"Environment: Ubuntu + Go 1.13\nOpen Go module #  Add forrowing environment variable:\n 1.11 or 1.12  export GO111MODULE=on export GOPROXY=https://goproxy.io  1.13 and later  go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct  Run that command after delete the origin environment variable.\n Usage: go get #  使用go module之后，go get 拉取依赖的方式就发生了变化 下载项目依赖\ngo get ./... 拉取最新的版本(优先择取 tag)\ngo get golang.org/x/text@latest 拉取 master 分支的最新 commit\ngo get golang.org/x/text@master 拉取 tag 为 v0.3.2 的 commit\ngo get golang.org/x/text@v0.3.2 拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2：\ngo get golang.org/x/text@342b2e 指定版本拉取，拉取v3版本\ngo get github.com/smartwalle/alipay/v3 更新\ngo get -u Usage: go mod #  初始化一个moudle，模块名为你项目名\ngo mod init \u0026lt;module name\u0026gt; 下载modules到本地cache 目前所有模块版本数据均缓存在$GOPATH/pkg/mod和$GOPATH/pkg/sum下\ngo mod download 编辑go.mod文件 选项有-json、-require和-exclude，可以使用帮助go help mod edit\ngo mod edit 以文本模式打印模块需求图\ngo mod graph 删除错误或者不使用的modules\ngo mod tidy 生成vendor目录\ngo mod vendor 验证依赖是否正确\ngo mod verify 查找依赖\ngo mod why Advance usage #  更新到最新版本\ngo get github.com/gogf/gf@version  如果没有指明 version 的情况下，则默认先下载打了 tag 的 release 版本，比如 v0.4.5 或者 v1.2.3；如果没有 release 版本，则下载最新的 pre release 版本，比如 v0.0.1-pre1。如果还没有则下载最新的 commit\n 更新到某个分支最新的代码\ngo get github.com/gogf/gf@master 更新到最新的修订版（只改bug的版本）\ngo get -u=patch github.com/gogf/gf 替代只能翻墙下载的库\ngo mod edit -replace=golang.org/x/crypto@v0.0.0=github.com/golang/crypto@latest go mod edit -replace=golang.org/x/sys@v0.0.0=github.com/golang/sys@latest 清理moudle 缓存\ngo clean -modcache 查看可下载版本\ngo list -m -versions github.com/gogf/gf "}),a.add({id:14,href:'/docs/ops/os/mac/',title:"Mac",section:"OS",content:"Directory #   "}),a.add({id:15,href:'/docs/ops/',title:"Ops",section:"Docs",content:"Operations #  Record something about software platform operations.\nDirectory #    OS     Git     Blog     Tools     Monitoring     Virtualization    "}),a.add({id:16,href:'/docs/ops/tools/swagger/',title:"Swagger",section:"Tools",content:"Abstract #  Swagger is the most popular API development tool. It follows the OpenAPI Specification (OpenAPI Specification, also referred to as OAS).It can run through the entire API ecosystem, such as API design, API documentation, testing, and deployment.\nSupport Specification #   Swagger 2.0 Openapi 3.0  Support Grammer #   Json Yaml  Tool #   Swagger Editer: an editor for writing Swagger documents, and also supports real-time document detection, API debugging and other functions. Swagger UI: a UI rendering tool used to render Swagger documents to provide a beautiful API interface. Swagger-codegen: a code generator that can build server-side stubs and client-side SDKs based on Swagger documents.  Preparation #  The Server need to support OCRS(Cross-origin resource sharing) Basic Thoughts:\n Add response header in each request:  Access-Control-Allow-Origin: * Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS Access-Control-Allow-Headers: Content-Type, Key, Authorization  Add OPTION method support: return 200 OK with the headers as below.  Swagger Editor #  Swagger-editor is a API editor, mainly used to write Swagger Document (RESTful API documents that comply with Swagger specifications).\nFuntionality #   Write Swagger documentation Real-time detection of whether the Swagger document complies with the Swagger specification Debug the API interface described in the Swagger document Convert Swagger documents (yaml to json, or json to yaml)  Deployment #  docker run -d -p 8080:8080 --name swagger-editor swaggerapi/swagger-editor Usage #  Open the website http://127.0.0.1:8080 in browers, then you can import/create your Openapi document.\nSwagger UI #  A set of HTML/CSS/JS framework for rendering Swagger documents to provide a beautiful API document interface.\nDeployment #  docker run -d -p 8081:8080 --name swagger-ui -v $(pwd):/usr/share/nginx/html/config swaggerapi/swagger-ui Usage #  Open the website http://127.0.0.1:8081 in browers.Chane the title to the json/yaml path that you mount, example: ./config/openapi.yaml\nGitlab Support #   Copy the OpenAPI document to the project change the document name start with \u0026ldquo;openapi\u0026rdquo; (not case sensitive) commit the change to the gitlab. Open the Gitlab in brower, open the document you commit.  If the openAPI document include the other openapi document, you should do something like the following example.\nExample Situation:OPENAPI-TS29503_Nudm_SDM.yaml will include TS29571_CommonData.yaml\n copy the TS29571_CommonData.yaml to the project change the name to OPENAPI-TS29571_CommonData.yaml replace all string from TS29571_CommonData.yaml to OPENAPI-TS29571_CommonData.yaml in OPENAPI-TS29503_Nudm_SDM.yaml, if OPENAPI-TS29571_CommonData.yaml and OPENAPI-TS29503_Nudm_SDM.yaml in different path, that you should add the relative path before OPENAPI-TS29503_Nudm_SDM.yaml, like ../OPENAPI-TS29503_Nudm_SDM.yaml  Reference #   Swagger "}),a.add({id:17,href:'/docs/dev/c/inline/',title:"关键字Inline的使用说明",section:"C",content:"作用 #  避免一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。\n规则 #   关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用 inline只适合函数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数  以下情况不宜使用内联：\n 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。  总结 #   内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收 获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline 不应该出现在函数的声明中）。 因此,将内联函数放在头文件里实现是合适的,省却你为每个文件实现一次的麻烦.而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为,即是说,如果不是每个文件里的定义都一样,那么,编译器展开的是哪一个,那要看具体的编译器而定.所以,最好将内联函数定义放在头文件中.   例子 #  #include \u0026lt;stdio.h\u0026gt; //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 \u0026gt; 0) ? \u0026quot;奇\u0026quot; : \u0026quot;偶\u0026quot;; } int main() { int i = 0; for (i=1; i \u0026lt; 100; i++) { printf(\u0026quot;i:%d 奇偶性:%s /n\u0026quot;, i, dbtest(i)); } } 上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2\u0026gt;0)?\u0026ldquo;奇\u0026rdquo;:\u0026ldquo;偶\u0026quot;这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。\n"}),a.add({id:18,href:'/docs/dev/c/__builtin_expect/',title:"__builtin_expect使用",section:"C",content:"环境要求 : GCC(version \u0026gt; v2.96)\n作用 #  允许程序员将最有可能执行的分支告诉编译器。这样编译器可以对代码进行优化，以减少指令跳转带来的性能下降。\n这个指令的写法为：__builtin_expect(EXP, N)。意思是：EXP==N的概率很大。\n源码及使用方法 #  源码声明如下：\nlong __builtin_expect(long exp, long c); 一般的使用方法是将__builtin_expect指令封装为likely和unlikely宏。这两个宏的写法如下.\n#define likely(x) __builtin_expect(!!(x), 1) //x很可能为真 #define unlikely(x) __builtin_expect(!!(x), 0) //x很可能为假 例子 #  int x, y; if(unlikely(x \u0026gt; 0)) y = 1; else y = -1; "}),a.add({id:19,href:'/docs/ops/blog/',title:"Blog",section:"Ops",content:"Directory #   "}),a.add({id:20,href:'/docs/dev/go/init/',title:"Init--初始化函数",section:"Go",content:"作用 #   初始化不能采用初始化表达式初始化的变量。 程序运行前的注册。 实现sync.Once功能。  规则 #   先于main函数自动执行。 不能被其他函数调用。 没有输入参数、返回值。 每个包可以有多个init函数。 包的每个源文件也可以有多个init函数。 同一个包的init执行顺序，golang没有明确定义。 不同包的init函数按照包导入的依赖关系决定执行顺序。  备注 #   设置GODEBUG环境变量: inittrace=1，可以在运行时会为每个包的 init 打印一行标准错误信息，总结其执行时间和内存分配。 若只想调用该包的init函数，不使用包导出的变量或者方法，可使用类似以下方法导入： import _ \u0026#34;net/http/pprof\u0026#34;  "}),a.add({id:21,href:'/docs/ops/virtualization/kubernetes/',title:"Kubernetes",section:"Virtualization",content:"Directory #   "}),a.add({id:22,href:'/docs/dev/rust/',title:"Rust",section:"Dev",content:"Directory #   "}),a.add({id:23,href:'/docs/sec/',title:"Sec",section:"Docs",content:"Security #  Record something about software security.\nDirectory #   "}),a.add({id:24,href:'/docs/ops/os/windows/',title:"Windows",section:"OS",content:"Directory #   "}),a.add({id:25,href:'/docs/ops/tools/bt_pannel/',title:"宝塔面板",section:"Tools",content:"适用环境 #   虚拟主机 本地环境 云服务器  特性 #   一键配置服务器环境（LAMP/LNMP） 一键安全重启 一键创建管理网站、ftp、数据库 一键配置（定期备份、数据导入、伪静态、301、SSL、子目录、反向代理、切换PHP版本） 一键安装常用PHP扩展(fileinfo、intl、opcache、imap、memcache、apc、redis、ioncube、imagick) 数据库一键导入导出 系统监控（CPU、内存、磁盘IO、网络IO） 防火墙端口放行SSH开启与关闭及SSH端口更改禁PING开启或关闭方便高效的文件管理器（上传、下载、压缩、解压、查看、编辑等等）计划任务（定期备份、日志切割、shell脚本）软件管理（一键安装、卸载、版本切换）  安装 #   centos：  yum install -y wget \u0026amp;\u0026amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh \u0026amp;\u0026amp; sh install.sh  ubuntu/deepin:  wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026amp;\u0026amp; sudo bash install.sh  Debian:  wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026amp;\u0026amp; bash install.sh  Fedora:  wget -O install.sh http://download.bt.cn/install/install_6.0.sh \u0026amp;\u0026amp; bash install.sh 登录 #  安装完成后会显示以下一些信息：\nBt-Panel: http://A.B.C.D:8888/******** username: ****** password: ****** 使用浏览器方位Bt-Panel后面的地址，然后根据提供的用户名和密码进行登录即可\n A.B.C.D是你设备的IP地址，初始登录需要时候后面的八位随机字符 username和password也是随机生成的，可以登录后进行修改\n 安装环境 #  登录后默认会提示安装LAMP或者LNMP，按需选择，等待完成即可\n LAMP : Linux + Apache + Mysql + PHP LNMP : Linux + Nginx + Mysql + PHP\n 使用 #  一般在页面进行操作，不过也提供终端命令操作，详情请参考： https://www.bt.cn/btcode.html\n"}),a.add({id:26,href:'/docs/dev/go/grpc/',title:"Grpc使用",section:"Go",content:"Install #   Install protoc  wget https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip unzip protoc-3.13.0-linux-x86_64.zip -d /usr/local/protoc export PATH=$PATH:/usr/local/protoc/bin source ~/.bashrc Download protoc-gen-go  go get -u github.com/golang/protobuf/protoc-gen-go go install $GOPATH/src/github.com/golang/protobuf/protoc-gen-go Usage #   Create *.proto file  // Specify syntax format, note that proto3 no supports required and optimal in proto2 anymore syntax = \u0026quot;proto3\u0026quot;; // Specifies the package name of the generated *.pb.go package grpc; // Specifies the package path of the generated *.pb.go package option go_package = \u0026quot;.;grpc\u0026quot;; // Service defines the service called by the development service DemoService { rpc DemoReq(DemoRequest) returns (DemoResponse) {} } message DemoRequest{ uint32 Id = 1; string Name = 2; } message DemoResponse{ } Generate  protoc -I . --go_out=plugins=grpc:. ./*.proto "}),a.add({id:27,href:'/docs/dev/html/',title:"Html",section:"Dev",content:"Directory #   "}),a.add({id:28,href:'/docs/others/',title:"Others",section:"Docs",content:"Directory #    职场相关    "}),a.add({id:29,href:'/docs/ops/tools/v2ray/',title:"SS/V2ray搭建",section:"Tools",content:"Shadowsock #  安装 #  $ cd /usr/local/src $ wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh $ chmod +x shadowsocks.sh $ systemctl stop firewalld \u0026amp;\u0026amp; systemctl disable firewalld $ ./shadowsocks.sh 2\u0026gt;\u0026amp;1 | tee shadowsocks.log 配置shadowsock #  Please enter password for shadowsocks-python (Default password: teddysun.com): // 配置登录密码 --------------------------- password = ******* --------------------------- Please enter a port for shadowsocks-python [1-65535] (Default port: 16849): //配置服务端口 --------------------------- port = 16849 --------------------------- Please select stream cipher for shadowsocks-python: 1) aes-256-gcm 2) aes-192-gcm 3) aes-128-gcm 4) aes-256-ctr 5) aes-192-ctr 6) aes-128-ctr 7) aes-256-cfb 8) aes-192-cfb 9) aes-128-cfb 10) camellia-128-cfb 11) camellia-192-cfb 12) camellia-256-cfb 13) chacha20-ietf-poly1305 14) chacha20-ietf 15) chacha20 16) rc4-md5 Which cipher you\u0026#39;d select(Default: aes-256-gcm): //选择加密协议 --------------------------- cipher = aes-256-cfb --------------------------- Press any key to start...or Press Ctrl+C to cancel 记录shadowsock信息 #  Congratulations, Shadowsocks-python server install completed! Your Server IP : *.*.*.* Your Server Port : 16849 Your Password : *********** Your Encryption Method: aes-256-cfb 服务使用 #  START: /etc/init.d/shadowsocks start STOP: /etc/init.d/shadowsocks stop RESTART: /etc/init.d/shadowsocks restart STATUS: /etc/init.d/shadowsocks status CONFIG: /etc/shadowsocks.json UNINSTALL: /usr/local/src/shadowsocks.sh uninstall 使用软件连接shadowsock即可 #  WIN : https://github.com/shadowsocks/shadowsocks-windows/releases Andriod ： 待添加\n加速 #  安全起见，最好先把服务器进行备份，然后执行以下操作\n$ wget \u0026quot;https://github.com/chiakge/Linux-NetSpeed/raw/master/tcp.sh\u0026quot; $ chmod +x tcp.sh $ ./tcp.sh 选择内核并重启 #   TCP加速 一键安装管理脚本 [v1.3.2] -- 就是爱生活 | 94ish.me -- 0. 升级脚本 --------------------内核管理-------------------- 1. 安装 BBR/BBR魔改版内核 2. 安装 BBRplus版内核 3. 安装 Lotserver(锐速)内核 --------------------加速管理-------------------- 4. 使用BBR加速 5. 使用BBR魔改版加速 6. 使用暴力BBR魔改版加速(不支持部分系统) 7. 使用BBRplus版加速 8. 使用Lotserver(锐速)加速 --------------------杂项管理-------------------- 9. 卸载全部加速 10. 系统配置优化 11. 退出脚本 ----------------------------------------------------- 当前状态: 已安装 BBR 加速内核 , BBR启动成功 请输入数字 [0-11]: 2 \u0026lt;-- Enter the num of the kernel V2ray #  bash \u0026lt; (curl -s -L https://git.io/v2ray.sh) "}),a.add({id:30,href:'/docs/ops/tools/',title:"Tools",section:"Ops",content:"Directory #    Samba     Swagger     宝塔面板     SS/V2ray搭建    "}),a.add({id:31,href:'/docs/ops/monitoring/',title:"Monitoring",section:"Ops",content:"Directory #   "}),a.add({id:32,href:'/docs/dev/shell/',title:"Shell",section:"Dev",content:"Directory #   "}),a.add({id:33,href:'/docs/dev/go/grpcurl/',title:"安装Grpcurl",section:"Go",content:"Environment:\n System: linux Go: 1.13+  Install #   Install dependent package  mkdir -p $GOPATH/src/google.golang.org git clone https://github.com/protocolbuffers/protobuf-go.git $GOPATH/src/google.golang.org/protobuf git clone https://github.com/googleapis/go-genproto.git $GOPATH/src/google.golang.org/genproto git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc git clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/net git clone https://github.com/golang/sys.git $GOPATH/src/golang.org/x/sys git clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/text Download grpcurl  go get github.com/fullstorydev/grpcurl Install  go install $GOPATH/src/github.com/fullstorydev/grpcurl/cmd/grpcurl  if tips no dependent package, go to $GOPATH/src/github.com/fullstorydev/grpcurl/ to run go build ./cmd/grpcurl\n"}),a.add({id:34,href:'/docs/dev/python/',title:"Python",section:"Dev",content:"Directory #   "}),a.add({id:35,href:'/docs/ops/virtualization/',title:"Virtualization",section:"Ops",content:"Directory #    Kvm     Docker     Kubernetes    "}),a.add({id:36,href:'/docs/dev/go/gvm/',title:"使用Gvm更换go版本",section:"Go",content:"Source Code Location: gvm\nInstall #  bash \u0026lt; \u0026lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) Usage #  gvm list # 列出当前安装的go版本 gvm listall # 列出可安装的go版本 gvm install go1.16 # 选择对应版本进行安装 gvm use go1.16 [--default] # 使用对应的go版本  Note: Go 1.5+ removed the C compilers from the toolchain and replaced them with one written in Go. Obviously, this creates a bootstrapping problem if you don\u0026rsquo;t already have a working Go install. In order to compile Go 1.5+, make sure Go 1.4 is installed first.\n Uninstall origin go verison #  Linux sudo rm -rf /usr/local/go Then edit /etc/profile to delete the following content:\n- export PATH=$PATH:/usr/local/go/bin MacOS sudo rm -rf /etc/paths.d/go  Uninstall #  gvm implode "}),a.add({id:37,href:'/docs/dev/embedded/',title:"Embedded",section:"Dev",content:"Directory #   "}),a.add({id:38,href:'/docs/dev/typescript/',title:"Typescript",section:"Dev",content:"Directory #   "}),a.add({id:39,href:'/docs/dev/data_structure/',title:"Data Structure",section:"Dev",content:"Directory #   "}),a.add({id:40,href:'/docs/dev/design_patterns/',title:"Design Patterns",section:"Dev",content:"Directory #   "})})()