<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on Sanjo's Note</title><link>http://note.shit-hub.com/docs/dev/c/</link><description>Recent content in C on Sanjo's Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://note.shit-hub.com/docs/dev/c/index.xml" rel="self" type="application/rss+xml"/><item><title>函数调用树生成器--Callgraph</title><link>http://note.shit-hub.com/docs/dev/c/callgraph_usage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://note.shit-hub.com/docs/dev/c/callgraph_usage/</guid><description>介绍 # Callgraph 是一个生成C代码函数调用树的工具，与以下三个工具配合使用：
cflow/calltree: 用于生成 C 函数调用树 graphviz: 处理 dot 文本图形语言 tree2dotx: 用于把 C 函数调用树转换为 dot 格式的脚本 安装 # Environment: Ubuntu 20.04
sudo apt-get install cflow graphviz 接下来安装 tree2dotx 和 Callgraph，这里都默认安装到 /usr/local/bin。
sudo wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/tree2dotx -o /usr/local/bin/tree2dotx sudo wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/callgraph -o /usr/local/bin/callgraph sudo chmod +x /usr/local/bin/{tree2dotx,callgraph} 使用 # callgraph -f main -d ./file.c -F &amp;#34;printf print&amp;#34; -D 2 -b firefox -f: 指定目标函数</description></item><item><title>关键字Inline的使用说明</title><link>http://note.shit-hub.com/docs/dev/c/inline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://note.shit-hub.com/docs/dev/c/inline/</guid><description>作用 # 避免一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。
规则 # 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用 inline只适合函数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数 以下情况不宜使用内联：
如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 总结 # 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收 获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline 不应该出现在函数的声明中）。 因此,将内联函数放在头文件里实现是合适的,省却你为每个文件实现一次的麻烦.而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为,即是说,如果不是每个文件里的定义都一样,那么,编译器展开的是哪一个,那要看具体的编译器而定.所以,最好将内联函数定义放在头文件中.  例子 # #include &amp;lt;stdio.h&amp;gt; //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 &amp;gt; 0) ? &amp;quot;奇&amp;quot; : &amp;quot;偶&amp;quot;; } int main() { int i = 0; for (i=1; i &amp;lt; 100; i++) { printf(&amp;quot;i:%d 奇偶性:%s /n&amp;quot;, i, dbtest(i)); } } 上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2&amp;gt;0)?</description></item></channel></rss>